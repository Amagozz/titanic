Va, diagrama del â€œmotor del juegoâ€ versiÃ³n profe-React ğŸ˜ğŸš¢

Te lo dejo en formato que puedes pegar tal cual en una diapositiva o en un .md para la clase.

---

## 1. Los actores del sistema (Titanic edition)

En nuestro componente Titanic tenemos:

* **Estados React**

  * `estado` â†’ `"parado" | "navegando" | "chocando" | "partido"`
  * `posX` â†’ posiciÃ³n horizontal del barco
  * `posColision` â†’ posiciÃ³n donde choca
* **Efectos (`useEffect`)**

  * Efecto 1 â†’ mueve el barco cuando `estado === "navegando"`
  * Efecto 2 â†’ detecta colisiÃ³n usando `getBoundingClientRect`
* **DOM + CSS**

  * `<div class="ship">` â†’ se mueve con `translateX(posX)`
  * `<div class="ship-inner ship-inner--crash">` â†’ tiembla
  * `<div class="ship-split">` â†’ dos mitades hundiÃ©ndose

---

## 2. Timeline simple: del render al choque

Puedes enseÃ±ar esta **lÃ­nea temporal**:

```text
1. Render inicial
   - estado = "parado"
   - posX = 0
   - React pinta barco quieto.

2. Clic en "Zarpar"
   - setEstado("navegando")
   - React vuelve a renderizar:
       estado = "navegando"
       posX = 0
   - Se ejecutan los useEffect.

3. useEffect de movimiento [estado]
   - Ve estado === "navegando"
   - Crea un setInterval â†’ cada 30ms: setPosX(x + 4)

4. Ticks del intervalo
   - posX: 0 â†’ 4 â†’ 8 â†’ 12 â†’ ...
   - Cada cambio de posX:
       - React vuelve a renderizar
       - Se ejecuta useEffect de colisiÃ³n [posX, estado]

5. useEffect de colisiÃ³n [posX, estado]
   - Solo actÃºa si estado === "navegando"
   - Lee shipRef e icebergRef
   - Calcula shipRect.right y icebergRect.left
   - Cuando shipRect.right >= icebergRect.left:
       - calcula solape
       - xAjustado = posX - solape
       - setPosColision(xAjustado)
       - setEstado("chocando")

6. Cambio a "chocando"
   - React vuelve a renderizar:
       estado = "chocando"
       posX = Ãºltimo valor
       posColision = xAjustado
   - El useEffect de movimiento se detiene (estado ya no es "navegando")
   - El barco se queda pegado al iceberg.

7. AnimaciÃ³n CSS de choque
   - CSS aÃ±ade temblor (ship-inner--crash)
   - Al terminar, se dispara onAnimationEnd:
       if (estado === "chocando") setEstado("partido")

8. Cambio a "partido"
   - React vuelve a renderizar:
       estado = "partido"
       posColision mantiene la posiciÃ³n del choque
   - JSX cambia:
       - ya NO se pinta el barco entero,
       - AHORA se pinta ship-split con las dos mitades
   - CSS hunde primero la mitad derecha y luego la izquierda.
```

---

## 3. Esquema visual tipo diagrama para diapositiva

Puedes usar algo asÃ­:

```text
             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   Clic      â”‚ setEstado(...)â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ setPosX(...)  â”‚
             â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
                    â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Render React  â”‚
            â”‚  (JSX â†’ DOM)   â”‚
            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
         DespuÃ©s de pintar
                   â”‚
                   â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  useEffect 1 (mov)    â”‚
       â”‚  depende de [estado]  â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
   mientras estado==="navegando"
   cada 30ms: setPosX(x+4)
                   â”‚
                   â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚  useEffect 2 (choque) â”‚
       â”‚ depende de [posX,estado]
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
   si derecha barco â‰¥ izquierda iceberg
   â†’ setPosColision(...), setEstado("chocando")
                   â”‚
                   â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Nuevo render  â”‚
            â”‚  estado=chocando
            â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
         CSS anima "crash"
          onAnimationEnd:
           setEstado("partido")
                   â”‚
                   â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚  Nuevo render  â”‚
            â”‚  estado=partidoâ”‚
            â”‚  se pintan dos â”‚
            â”‚  mitades       â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. Micro-guion para explicarlo en clase

Te lo dejo en frases que puedes decir prÃ¡cticamente tal cual:

1. **â€œReact no estÃ¡ todo el rato en bucle, no es un while(true).**
   Solo se vuelve a ejecutar cuando cambian los estados (`setEstado`, `setPosX`, etc.).â€

2. **â€œ`useEffect` son sensores.â€**
   Uno vigila `estado`, otro vigila `posX` + `estado`.
   Cuando cambia algo que vigilan, se despiertan.

3. **â€œEl de movimiento es nuestro motor.â€**
   Mientras el estado sea `"navegando"`, cada 30ms avanzamos un poco el barco.

4. **â€œEl de colisiÃ³n es nuestro Ã¡rbitro.â€**
   Cada vez que cambia `posX`, calcula si el barco ha llegado al iceberg.

5. **â€œEn cuanto detectamos choque, cambiamos el estado a â€˜chocandoâ€™ y guardamos la posiciÃ³n.â€**
   Eso detiene el motor de movimiento y lanza la animaciÃ³n de choque.

6. **â€œCuando la animaciÃ³n de choque termina, otro evento (onAnimationEnd) cambia el estado a â€˜partidoâ€™ y React cambia quÃ© pinta: ahora son dos mitades hundiÃ©ndose.â€**

Y remate:

> â€œO sea, lo que hace que esto parezca un minijuego no es magia:
> son solo estados que cambian + `useEffect` que responde a esos cambios.â€

---

Con esto tienes un esquema bastante redondo para:

* explicar `useEffect`,
* diferenciar **render vs efectos**,
* y ligar lÃ³gica de juego con estados y animaciones CSS.

Luego este mismo patrÃ³n te sirve para cualquier otro miniproyecto React gamificado que montes con el grupo.
