## 1. Los actores del sistema (Titanic edition)

En nuestro componente Titanic tenemos:

* **Estados React**

  * `estado` → `"parado" | "navegando" | "chocando" | "partido"`
  * `posX` → posición horizontal del barco
  * `posColision` → posición donde choca
* **Efectos (`useEffect`)**

  * Efecto 1 → mueve el barco cuando `estado === "navegando"`
  * Efecto 2 → detecta colisión usando `getBoundingClientRect`
* **DOM + CSS**

  * `<div class="ship">` → se mueve con `translateX(posX)`
  * `<div class="ship-inner ship-inner--crash">` → tiembla
  * `<div class="ship-split">` → dos mitades hundiéndose

---

## 2. Timeline simple: del render al choque

Puedes enseñar esta **línea temporal**:

```text
1. Render inicial
   - estado = "parado"
   - posX = 0
   - React pinta barco quieto.

2. Clic en "Zarpar"
   - setEstado("navegando")
   - React vuelve a renderizar:
       estado = "navegando"
       posX = 0
   - Se ejecutan los useEffect.

3. useEffect de movimiento [estado]
   - Ve estado === "navegando"
   - Crea un setInterval → cada 30ms: setPosX(x + 4)

4. Ticks del intervalo
   - posX: 0 → 4 → 8 → 12 → ...
   - Cada cambio de posX:
       - React vuelve a renderizar
       - Se ejecuta useEffect de colisión [posX, estado]

5. useEffect de colisión [posX, estado]
   - Solo actúa si estado === "navegando"
   - Lee shipRef e icebergRef
   - Calcula shipRect.right y icebergRect.left
   - Cuando shipRect.right >= icebergRect.left:
       - calcula solape
       - xAjustado = posX - solape
       - setPosColision(xAjustado)
       - setEstado("chocando")

6. Cambio a "chocando"
   - React vuelve a renderizar:
       estado = "chocando"
       posX = último valor
       posColision = xAjustado
   - El useEffect de movimiento se detiene (estado ya no es "navegando")
   - El barco se queda pegado al iceberg.

7. Animación CSS de choque
   - CSS añade temblor (ship-inner--crash)
   - Al terminar, se dispara onAnimationEnd:
       if (estado === "chocando") setEstado("partido")

8. Cambio a "partido"
   - React vuelve a renderizar:
       estado = "partido"
       posColision mantiene la posición del choque
   - JSX cambia:
       - ya NO se pinta el barco entero,
       - AHORA se pinta ship-split con las dos mitades
   - CSS hunde primero la mitad derecha y luego la izquierda.
```

---

## 3. Esquema visual tipo diagrama para diapositiva

Puedes usar algo así:

```text
             ┌───────────────┐
   Clic      │ setEstado(...)│
────────────▶│ setPosX(...)  │
             └──────┬────────┘
                    │
                    ▼
            ┌────────────────┐
            │  Render React  │
            │  (JSX → DOM)   │
            └──────┬─────────┘
                   │
         Después de pintar
                   │
                   ▼
       ┌───────────────────────┐
       │  useEffect 1 (mov)    │
       │  depende de [estado]  │
       └───────────────────────┘
                   │
   mientras estado==="navegando"
   cada 30ms: setPosX(x+4)
                   │
                   ▼
       ┌───────────────────────┐
       │  useEffect 2 (choque) │
       │ depende de [posX,estado]
       └───────────────────────┘
                   │
   si derecha barco ≥ izquierda iceberg
   → setPosColision(...), setEstado("chocando")
                   │
                   ▼
            ┌────────────────┐
            │  Nuevo render  │
            │  estado=chocando
            └──────┬─────────┘
                   │
         CSS anima "crash"
          onAnimationEnd:
           setEstado("partido")
                   │
                   ▼
            ┌────────────────┐
            │  Nuevo render  │
            │  estado=partido│
            │  se pintan dos │
            │  mitades       │
            └────────────────┘
```

---

## 4. Micro-guion para explicarlo en clase

Te lo dejo en frases que puedes decir prácticamente tal cual:

1. **“React no está todo el rato en bucle, no es un while(true).**
   Solo se vuelve a ejecutar cuando cambian los estados (`setEstado`, `setPosX`, etc.).”

2. **“`useEffect` son sensores.”**
   Uno vigila `estado`, otro vigila `posX` + `estado`.
   Cuando cambia algo que vigilan, se despiertan.

3. **“El de movimiento es nuestro motor.”**
   Mientras el estado sea `"navegando"`, cada 30ms avanzamos un poco el barco.

4. **“El de colisión es nuestro árbitro.”**
   Cada vez que cambia `posX`, calcula si el barco ha llegado al iceberg.

5. **“En cuanto detectamos choque, cambiamos el estado a ‘chocando’ y guardamos la posición.”**
   Eso detiene el motor de movimiento y lanza la animación de choque.

6. **“Cuando la animación de choque termina, otro evento (onAnimationEnd) cambia el estado a ‘partido’ y React cambia qué pinta: ahora son dos mitades hundiéndose.”**

Y remate:

> “O sea, lo que hace que esto parezca un minijuego no es magia:
> son solo estados que cambian + `useEffect` que responde a esos cambios.”

